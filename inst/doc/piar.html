<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Making price indexes</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Making price indexes</h1>



<p>Most price indexes are made with a two-step procedure, where
period-over-period <em>elemental indexes</em> are calculated for a
collection of <em>elemental aggregates</em> at each point in time, and
then aggregated according to a <em>price index aggregation
structure</em>. These indexes can then be chained together to form a
time series that gives the evolution of prices with respect to a fixed
base period. The <strong>piar</strong> package contains a collections of
functions that revolve around this work flow, making it easy to build
standard price indexes in <strong>R</strong>.</p>
<p>The purpose of this vignette is to give several extended examples of
how to use the functions in this package to make different types of
price indexes. This should serve both as a introduction to the
functionality in <strong>piar</strong>, and a reference for solving
specific index-number problems.</p>
<div id="matched-sample-index" class="section level2">
<h2>Matched-sample index</h2>
<p>The first example covers calculating a matched-sample index, where a
fixed set of businesses each provide prices for a collection of products
over time. The products reported by a businesses can change over time,
but the set of businesses is fixed for the duration of the sample. Each
businesses has a weight that is established when the sample is drawn,
and represents a particular segment of the economy.</p>
<p>The usual approach for calculating a matched-sample index starts by
computing the elemental index for each business as an equally-weighted
geometric mean of price relatives (i.e., a Jevons index). From there,
index values for different segments of the economy are calculated as an
arithmetic mean of the elemental indexes, using the businesses-level
weights (either a Young or Lowe index, depending how the weights are
constructed).</p>
<p>The <code>ms_prices</code> dataset has price data for five businesses
over four quarters, and the <code>ms_weights</code> dataset has the
weight data. Note that these data have fairly realistic patterns of
missing data.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(piar)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">head</span>(ms_prices)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&gt;   period business product price</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co">#&gt; 1 202001       B1       1  1.14</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">#&gt; 2 202001       B1       2    NA</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">#&gt; 3 202001       B1       3  6.09</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">#&gt; 4 202001       B2       4  6.23</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt; 5 202001       B2       5  8.61</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt; 6 202001       B2       6  6.40</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>ms_weights</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">#&gt;   business classification weight</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">#&gt; 1       B1             11    553</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">#&gt; 2       B2             11    646</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">#&gt; 3       B3             11    312</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="co">#&gt; 4       B4             12    622</span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">#&gt; 5       B5             12    330</span></span></code></pre></div>
<p>The <code>elemental_index()</code> function makes, well, elemental
indexes, using information on price relatives, elemental aggregates
(businesses), and time periods (quarters). By default it makes a Jevons
index, but any bilateral generalized-mean index is possible. The only
wrinkle is that price data here are in levels, and not relatives, but
the <code>price_relative()</code> function can make the necessary
conversion.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>relative <span class="ot">&lt;-</span> <span class="fu">with</span>(ms_prices, <span class="fu">price_relative</span>(price, period, product))</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>ms_elemental <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  ms_prices,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  <span class="fu">elemental_index</span>(relative, period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>ms_elemental</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co">#&gt; B2      1       NaN       NaN 2.770456</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></span></code></pre></div>
<p>(Homogeneous elemental aggregates often leads to unit-value elemental
indexes that are not based on price relatives. These cases can be dealt
with by first aggregating prices for each elemental aggregate,
<code>aggregate(price ~ period + product, ms_prices, mean)</code>, at
each point in time with an arithmetic mean, then forming price relatives
to feed into <code>elemental_index()</code>.)</p>
<p>As with most functions in <strong>R</strong>, missing values are
contagious by default in <strong>piar</strong>. Setting
<code>na.rm = TRUE</code> in <code>elemental_index()</code> means that
missing price relatives are ignored, which is equivalent to imputing
these missing relatives with the value of the elemental index for the
respective businesses (i.e., parental or overall mean imputation). Other
types of imputation are possible, and are the topic of a subsequent
example.</p>
<p>The <code>elemental_index()</code> function returns a special index
object, and there are a number of methods for working with these
objects. Probably the most useful of these methods allows the resulting
elemental indexes to be extracted like a matrix, even though it’s not a
matrix. (Note that there are only indexes for four businesses, not five,
because the fifth business never reports any prices; an elemental index
can be made for this business with a small change to the call to
<code>elemental_index()</code>.)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>ms_elemental[, <span class="st">&quot;202004&quot;</span>]</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 1 time periods </span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">#&gt;      202004</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">#&gt; B1      NaN</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#&gt; B2 2.770456</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt; B3 0.537996</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt; B4 4.576286</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>ms_elemental[<span class="st">&quot;B1&quot;</span>, ]</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 1 levels over 4 time periods </span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003 202004</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939    NaN</span></span></code></pre></div>
<p>With the elemental indexes out of the way, it’s time to make a
price-index aggregation structure that maps each business to its
position in the aggregation hierarchy. The only hiccup is unpacking the
digit-wise classification for each businesses that defines the
hierarchy. That’s the job of the <code>expand_classification()</code>
function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>hierarchy <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  ms_weights, </span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fu">expand_classification</span>(classification), <span class="fu">list</span>(business))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>pias <span class="ot">&lt;-</span> <span class="fu">aggregation_structure</span>(hierarchy, ms_weights<span class="sc">$</span>weight)</span></code></pre></div>
<p>It is now simple to aggregate the elemental indexes according to this
aggregation structure with the <code>aggregate()</code> function. As
with the elemental indexes, missing values are ignored by setting
<code>na.rm = TRUE</code>, which is equivalent to parentally imputing
missing values. Note that, unlike the elemental indexes, missing values
are filled in to ensure the index can be chained over time.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>ms_index <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(ms_elemental, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>ms_index</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></span></code></pre></div>
<p>Although simple, this example covers the core functionality of
<strong>piar</strong>. The remaining examples in the vignette build on
this one by adding complexities that often arise in practice.</p>
</div>
<div id="chaining" class="section level2">
<h2>Chaining</h2>
<p>The <code>elemental_index()</code> function makes period-over-period
elemental indexes by default, which can then be aggregated to make a
period-over-period index. Chaining an index is the process of taking the
cumulative product of each of these period-over-period indexes to make a
time series that compares prices to a fixed base period.</p>
<p>The <code>chain()</code> function can be used to chain the values in
an index object.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>ms_index_chained <span class="ot">&lt;-</span> <span class="fu">chain</span>(ms_index)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>ms_index_chained</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; Aggregate fixed-base price index for 8 levels over 4 time periods </span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></span></code></pre></div>
<p>This gives almost the same result as directly manipulating the index
as a matrix, except that the former returns an index object (not a
matrix).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">t</span>(<span class="fu">apply</span>(<span class="fu">as.matrix</span>(ms_index), <span class="dv">1</span>, cumprod))</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></span></code></pre></div>
<p>Chained indexes often need be to rebased, and this can be done with
the <code>rebase()</code> function. For example, rebasing the index so
that 202004 is the base period just requires dividing the chained index
by the slice for 202004.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">rebase</span>(ms_index_chained, ms_index_chained[, <span class="st">&quot;202004&quot;</span>])</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#&gt; Aggregate fixed-base price index for 8 levels over 4 time periods </span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#&gt;       202001    202002    202003 202004</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt; 1  0.2644428 0.3439671 0.3656626      1</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt; 11 0.4593084 0.5974334 0.6351161      1</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt; 12 0.1580295 0.2055527 0.2185178      1</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt; B1 2.1229774 1.8998731 0.6351161      1</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt; B2 0.2610357 0.3395354 0.3609514      1</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">#&gt; B3 0.5626806 1.1366169 1.8587499      1</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">#&gt; B4 0.1580295 0.2055527 0.2185178      1</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt; B5 0.1580295 0.2055527 0.2185178      1</span></span></code></pre></div>
<p>In some cases the base period is the average of several periods;
setting the base period to the second half of 2020 just requires
averaging the index over subperiods before rebasing.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">rebase</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  ms_index_chained,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="fu">mean</span>(ms_index_chained, <span class="at">window =</span> <span class="dv">2</span>)[, <span class="st">&quot;202003&quot;</span>]</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt; Aggregate fixed-base price index for 8 levels over 4 time periods </span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt;       202001    202002    202003    202004</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; 1  0.3872740 0.5037366 0.5355095 1.4644905</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; 11 0.5618052 0.7307535 0.7768452 1.2231548</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; 12 0.2593798 0.3373815 0.3586616 1.6413384</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; B1 2.5967299 2.3238388 0.7768452 1.2231548</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; B2 0.3836077 0.4989677 0.5304398 1.4695602</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co">#&gt; B3 0.3936550 0.7951845 1.3003935 0.6996065</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co">#&gt; B4 0.2593798 0.3373815 0.3586616 1.6413384</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="co">#&gt; B5 0.2593798 0.3373815 0.3586616 1.6413384</span></span></code></pre></div>
</div>
<div id="multi-dimensional-aggregation-structures" class="section level2">
<h2>Multi-dimensional aggregation structures</h2>
<p>Price indexes are often aggregated over multiple dimensions. Matched
sample indexes that use sequential Poisson sampling are a good example,
as there are usually take-all and take-some strata in addition to, say,
an industry classification.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>ms_weights<span class="sc">$</span>stratum <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TA&quot;</span>, <span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TS&quot;</span>)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>ms_weights</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#&gt;   business classification weight stratum</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#&gt; 1       B1             11    553      TS</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt; 2       B2             11    646      TA</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt; 3       B3             11    312      TS</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt; 4       B4             12    622      TS</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt; 5       B5             12    330      TS</span></span></code></pre></div>
<p>The easiest way to deal with multiple digit-wise classifications is
to turn them into one classification. In this example the “stratum”
dimension comes before the “classification” dimension for the purposes
of parental imputation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>classification_sps <span class="ot">&lt;-</span> <span class="fu">with</span>(ms_weights, <span class="fu">paste0</span>(classification, stratum))</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>classification_sps</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">#&gt; [1] &quot;11TS&quot; &quot;11TA&quot; &quot;11TS&quot; &quot;12TS&quot; &quot;12TS&quot;</span></span></code></pre></div>
<p>This classification can be expanded with the
<code>expand_classification()</code> function as before, just with an
extra instruction to say that the last “digit” in the classification is
two characters wide, not one.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>classification_sps <span class="ot">&lt;-</span> <span class="fu">expand_classification</span>(</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  classification_sps,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="at">width =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>)</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>pias_sps <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  ms_weights, </span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  <span class="fu">aggregation_structure</span>(<span class="fu">c</span>(classification_sps, <span class="fu">list</span>(business)), weight)</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>)</span></code></pre></div>
<p>The elemental indexes can now be aggregated according to this new
aggregation structure.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">aggregate</span>(ms_elemental, pias_sps, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 11 levels over 4 time periods </span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt;      202001    202002    202003   202004</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co">#&gt; 1         1 1.3007239 1.0630743 2.684412</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co">#&gt; 11        1 1.3007239 1.0630743 1.492443</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co">#&gt; 12        1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co">#&gt; 11TS      1 1.3007239 1.0630743 0.537996</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="co">#&gt; 11TA      1 1.3007239 1.0630743 2.770456</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co">#&gt; 12TS      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co">#&gt; B1        1 0.8949097 0.3342939 0.537996</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="co">#&gt; B2        1 1.3007239 1.0630743 2.770456</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="co">#&gt; B3        1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co">#&gt; B4        1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="co">#&gt; B5        1 1.3007239 1.0630743 4.576286</span></span></code></pre></div>
</div>
<div id="computing-the-shadow-of-an-index" class="section level2">
<h2>Computing the shadow of an index</h2>
<p>It’s often useful to determine which higher-level index values are
missing, and subsequently get imputed during aggregation (i.e., compute
the shadow of an index). This is simple to do if there’s an elemental
index for each elemental aggregate in the aggregation structure.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  ms_prices,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>    relative, period, <span class="fu">factor</span>(business, ms_weights<span class="sc">$</span>business),</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    <span class="at">na.rm =</span> <span class="cn">TRUE</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>  )</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>)</span></code></pre></div>
<p>The idea is to simply aggregate an indicator for missingness to get a
matrix that gives the share of missing elemental indexes for each
higher-level index.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>pias_matrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(pias) <span class="sc">&gt;</span> <span class="dv">0</span> </span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>pias_matrix <span class="sc">%*%</span> <span class="fu">is.na</span>(ms_elemental2) <span class="sc">/</span> <span class="fu">rowSums</span>(pias_matrix)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt; 1     0.4 0.6000000 0.6000000 0.4000000</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt; 11    0.0 0.3333333 0.3333333 0.3333333</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#&gt; 12    1.0 1.0000000 1.0000000 0.5000000</span></span></code></pre></div>
<p>A value of 1 means that there are no non-missing elemental indexes,
and that the value for this level of the index is imputed from its
parent in the aggregation structure. A value below 1 but above zero
means that some but not all elemental indexes are missing, and the index
value for this level is based on the non-missing elemental indexes. A
value of zero means there’s no imputation for this level of the
index.</p>
</div>
<div id="non-parental-imputation-during-aggregation" class="section level2">
<h2>Non-parental imputation during aggregation</h2>
<p>Parental imputation is the usual way to impute missing index values
during aggregation, and it is simple to do with
<code>aggregate()</code>. In some cases, however, a business-level index
may get imputed with the value for, say, another business, rather than
for an entire group of businesses. The simplest way to do this sort of
imputation is to alter the elemental indexes prior to aggregation. It is
also possible to augment the aggregation structure with an imputation
layer, but this is more complex.</p>
<p>Suppose that missing index values for business B2 should be imputed
as 1, rather than the value for group 11. This replacement can be done
as if the index was a matrix.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> ms_elemental</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>ms_elemental2[<span class="st">&quot;B2&quot;</span>, <span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>ms_elemental2</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; B2      1 1.0000000 1.0000000 2.770456</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></span></code></pre></div>
<p>The index can now be aggregated as usual.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">aggregate</span>(ms_elemental2, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co">#&gt; 1       1 1.1721550 1.0400686 2.626560</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="co">#&gt; 11      1 1.1721550 1.0400686 1.398142</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt; 12      1 1.1721550 1.0400686 4.576286</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.398142</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; B2      1 1.0000000 1.0000000 2.770456</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt; B4      1 1.1721550 1.0400686 4.576286</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; B5      1 1.1721550 1.0400686 4.576286</span></span></code></pre></div>
</div>
<div id="alternate-index-number-formulas" class="section level2">
<h2>Alternate index-number formulas</h2>
<p>By default, the <code>elemental_index()</code> function calculates a
Jevons index. Although this is the standard index-number formula for
making elemental indexes, many other types of index-numbers are
possible. The Carli index (equally-weighted arithmetic mean of price
relatives) is the main competitor to the Jevons, and requires specifying
the order of the index <code>r</code> when calling
<code>elemental_index()</code>. An order of 1 corresponds to an
arithmetic mean.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">with</span>(</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  ms_prices, </span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(relative, period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span>, <span class="at">r =</span> <span class="dv">1</span>)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>)</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt;    202001     202002    202003   202004</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt; B1      1  0.8949097 0.3342939      NaN</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; B2      1        NaN       NaN 5.155942</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt; B3      1 23.7480455 2.4900997 0.607197</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; B4    NaN        NaN       NaN 9.368610</span></span></code></pre></div>
<p>The Coggeshall index (equally-weighted harmonic mean of price
relatives) is another competitor to the Jevons, but is seldom used in
practice. Despite it being more exotic, it is just as easy to make by
specifying an order <code>r</code> of -1.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">with</span>(</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  ms_prices,</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(relative, period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span>, <span class="at">r =</span> <span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>)</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939       NaN</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co">#&gt; B2      1       NaN       NaN 1.7205750</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="co">#&gt; B3      1 0.6591433 0.8185743 0.4746769</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="co">#&gt; B4    NaN       NaN       NaN 2.2353790</span></span></code></pre></div>
<p>The type of mean used to aggregate elemental indexes can be
controlled in the same way in the call to <code>aggregate()</code>. The
default makes an arithmetic index, but any type of generalized-mean
index is possible.</p>
<p>Many superlative indexes can be made by supplying unequal and
(usually) time-varying weights when making the elemental indexes. These
weights often come from information on quantities.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>ms_prices2 <span class="ot">&lt;-</span> <span class="fu">transform</span>(ms_prices, <span class="at">quantity =</span> <span class="dv">10</span> <span class="sc">-</span> price)</span></code></pre></div>
<p>The Tornqvist index is a popular superlative index-number formula,
using average period-over-period value shares as the weights in a
geometric mean. The only tricky part is making the weights from data on
prices and quantities.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">library</span>(gpindex)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>tw <span class="ot">&lt;-</span> <span class="fu">grouped</span>(<span class="fu">index_weights</span>(<span class="st">&quot;Tornqvist&quot;</span>))</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>ms_prices2[<span class="fu">c</span>(<span class="st">&quot;back_price&quot;</span>, <span class="st">&quot;back_quantity&quot;</span>)] <span class="ot">&lt;-</span> </span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>  ms_prices2[<span class="fu">back_period</span>(ms_prices2<span class="sc">$</span>period, ms_prices2<span class="sc">$</span>product),</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>             <span class="fu">c</span>(<span class="st">&quot;price&quot;</span>, <span class="st">&quot;quantity&quot;</span>)]</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>ms_prices2 <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(ms_prices2) <span class="co"># can&#39;t have NAs for Tornqvist weights</span></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>ms_prices2<span class="sc">$</span>weight <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>  ms_prices2,</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>  <span class="fu">tw</span>(</span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>    price, back_price, quantity, back_quantity,</span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>    <span class="at">group =</span> <span class="fu">interaction</span>(period, business)</span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>  )</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a>)</span></code></pre></div>
<p>As <code>elemental_index()</code> makes a geometric index by default,
all that is needed to make a Tornqvist index is to provide the
weights.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">with</span>(</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>  ms_prices2,</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(price <span class="sc">/</span> back_price, period, business, weight)</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>)</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a><span class="co">#&gt; B2      1       NaN       NaN 2.165152</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a><span class="co">#&gt; B3      1 0.9520982 1.5913929 0.542372</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a><span class="co">#&gt; B4    NaN       NaN       NaN 5.904237</span></span></code></pre></div>
</div>
<div id="percent-change-contributions" class="section level2">
<h2>Percent-change contributions</h2>
<p>It’s often convenient to decompose an index into the (additive)
contribution of each price relative, also known as the percent-change
contributions. This can be done with the same work flow as in the
previous examples, specifying <code>contrib = TRUE</code> when calling
<code>elemental_index()</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>ms_elemental <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  ms_prices,</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(relative, period, business, <span class="at">contrib =</span> <span class="cn">TRUE</span>, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>)</span></code></pre></div>
<p>As with index values, percent-change contributions for a given level
of the index can be extracted as a matrix.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="fu">contrib</span>(ms_elemental)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="co">#&gt;   202001     202002     202003 202004</span></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="co">#&gt; 1      0  0.0000000  0.0000000      0</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a><span class="co">#&gt; 2     NA         NA -0.6657061      0</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="co">#&gt; 3      0 -0.1050903         NA     NA</span></span></code></pre></div>
<p>Aggregating the elemental indexes automatically aggregates
percent-change contributions, so no extra steps are needed after the
elemental indexes are made.</p>
</div>
<div id="updating-a-basket" class="section level2">
<h2>Updating a basket</h2>
<p>The functions in <strong>piar</strong> are all designed to work
within a “basket”, which is a fancy way of saying within a given
aggregation structure. Over time, however, aggregation structures change
as the weights used to aggregate an index get updated, and new samples
of businesses are drawn. The general approach to keep the time series
going is to “chain” the index across baskets.</p>
<p>It is easier to see how to chain an index over time with a simple
example that just splits the <code>ms_prices</code> data in two.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>ms_prices1 <span class="ot">&lt;-</span> <span class="fu">subset</span>(ms_prices, period <span class="sc">&lt;=</span> <span class="st">&quot;202003&quot;</span>)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>ms_prices2 <span class="ot">&lt;-</span> <span class="fu">subset</span>(ms_prices, period <span class="sc">&gt;=</span> <span class="st">&quot;202003&quot;</span>)</span></code></pre></div>
<p>The index for the first basket can be calculate as usual.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>ms_elemental1 <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>  ms_prices1, </span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>    <span class="fu">price_relative</span>(price, period, product),</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>    period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>  )</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>)</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>ms_index1 <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(ms_elemental1, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>ms_index1</span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 3 time periods </span></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003</span></span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.0630743</span></span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.0630743</span></span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.0630743</span></span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939</span></span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.0630743</span></span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355</span></span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.0630743</span></span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.0630743</span></span></code></pre></div>
<p>Nothing special needs to be done to make the elemental indexes for
the new basket, but it’s easier to remove the index values of 1 for
quarter 3 2020.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> ms_prices2 <span class="sc">|&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>  <span class="fu">transform</span>(<span class="at">rel =</span> <span class="fu">price_relative</span>(price, period, product)) <span class="sc">|&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>  <span class="fu">subset</span>(period <span class="sc">&gt;</span> <span class="st">&quot;202003&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>  <span class="fu">with</span>(<span class="fu">elemental_index</span>(rel, period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<p>Aggregating these elemental indexes, however, requires an aggregation
structure. The results of the first example can be reproduced by simply
“price updating” the original weights, then building the aggregation
structure as usual.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>ms_index2 <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(ms_elemental2, <span class="fu">update</span>(pias, ms_index1), <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>ms_index2</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 1 time periods </span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="co">#&gt;      202004</span></span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a><span class="co">#&gt; 1  2.734761</span></span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a><span class="co">#&gt; 11 1.574515</span></span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a><span class="co">#&gt; 12 4.576286</span></span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a><span class="co">#&gt; B1 1.574515</span></span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a><span class="co">#&gt; B2 2.770456</span></span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a><span class="co">#&gt; B3 0.537996</span></span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a><span class="co">#&gt; B4 4.576286</span></span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a><span class="co">#&gt; B5 4.576286</span></span></code></pre></div>
<p>This produces two sets of period-over-period indexes that can be
stacked together and then chained.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="fu">chain</span>(<span class="fu">stack</span>(ms_index1, ms_index2))</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="co">#&gt; Aggregate fixed-base price index for 8 levels over 4 time periods </span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></span></code></pre></div>
</div>
<div id="carry-forward-imputation" class="section level2">
<h2>Carry-forward imputation</h2>
<p>The previous examples used parental imputation to both impute missing
price relatives when calculating the elemental indexes, and to impute
missing elemental indexes during aggregation. Another common imputation
strategy when making elemental indexes is to carry forward the previous
price to impute for missing prices, and parentally impute missing
elemental indexes during aggregation. As the
<code>elemental_index()</code> function accepts price relatives as its
input, other types of imputations can be done prior to passing price
relatives to this function.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>  ms_prices, </span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>    <span class="fu">price_relative</span>(<span class="fu">carry_forward</span>(price, period, product), period, product),</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>    period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span></span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>  )</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>)</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>ms_elemental2</span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 4 time periods </span></span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.5781816 1.000000</span></span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a><span class="co">#&gt; B2      1 1.0000000 0.1777227 2.770456</span></span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></span></code></pre></div>
<p>Aggregation follows the same steps as in the previous examples, with
missing values set to be ignored in order to parentally impute missing
elemental indexes.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>ms_index <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(ms_elemental2, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a> </span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>ms_index</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="co">#&gt; 1       1 1.1721550 0.8082981 2.2653614</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co">#&gt; 11      1 1.1721550 0.8082981 0.8093718</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="co">#&gt; 12      1 1.1721550 0.8082981 4.5762862</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.5781816 1.0000000</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a><span class="co">#&gt; B2      1 1.0000000 0.1777227 2.7704563</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.5379960</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="co">#&gt; B4      1 1.1721550 0.8082981 4.5762862</span></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a><span class="co">#&gt; B5      1 1.1721550 0.8082981 4.5762862</span></span></code></pre></div>
</div>
<div id="calculating-an-index-from-multiple-sources" class="section level2">
<h2>Calculating an index from multiple sources</h2>
<p>All of the examples so far have built an index from a single source
of price data. In many cases the elemental indexes are built from
multiple sources of data, either because no single source of data has
the necessary coverage, or different index-number formulas are employed
for different elemental aggregates.</p>
<p>It is straightforward to merge index objects together, provided
they’re for the same time periods. To keep the example simple, suppose
that <code>ms_prices</code> is split in two.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>ms_prices1 <span class="ot">&lt;-</span> <span class="fu">subset</span>(ms_prices, business <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;B1&quot;</span>, <span class="st">&quot;B2&quot;</span>, <span class="st">&quot;B3&quot;</span>))</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>ms_prices2 <span class="ot">&lt;-</span> <span class="fu">subset</span>(ms_prices, business <span class="sc">==</span> <span class="st">&quot;B4&quot;</span>)</span></code></pre></div>
<p>Elemental indexes can be made for both groups separately with the
usual recipe. Note that there is no data for business B4 in the first
two periods, so the time periods need to be made explicit.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>ms_elemental1 <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  ms_prices1, </span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>  <span class="fu">elemental_index</span>(</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>    <span class="fu">price_relative</span>(price, period, product),</span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>    period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>  )</span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>)</span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a>ms_elemental1</span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 3 levels over 4 time periods </span></span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a><span class="co">#&gt; B2      1       NaN       NaN 2.770456</span></span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a></span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> ms_prices2 <span class="sc">|&gt;</span></span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a>  <span class="fu">transform</span>(<span class="at">period =</span> <span class="fu">factor</span>(period, <span class="at">levels =</span> <span class="fu">time</span>(ms_elemental1))) <span class="sc">|&gt;</span></span>
<span id="cb33-18"><a href="#cb33-18" tabindex="-1"></a>  <span class="fu">with</span>(</span>
<span id="cb33-19"><a href="#cb33-19" tabindex="-1"></a>    <span class="fu">elemental_index</span>(</span>
<span id="cb33-20"><a href="#cb33-20" tabindex="-1"></a>      <span class="fu">price_relative</span>(price, period, product),</span>
<span id="cb33-21"><a href="#cb33-21" tabindex="-1"></a>      period, business, <span class="at">na.rm =</span> <span class="cn">TRUE</span></span>
<span id="cb33-22"><a href="#cb33-22" tabindex="-1"></a>    )</span>
<span id="cb33-23"><a href="#cb33-23" tabindex="-1"></a>  )</span>
<span id="cb33-24"><a href="#cb33-24" tabindex="-1"></a></span>
<span id="cb33-25"><a href="#cb33-25" tabindex="-1"></a>ms_elemental2</span>
<span id="cb33-26"><a href="#cb33-26" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 1 levels over 4 time periods </span></span>
<span id="cb33-27"><a href="#cb33-27" tabindex="-1"></a><span class="co">#&gt;    202001 202002 202003   202004</span></span>
<span id="cb33-28"><a href="#cb33-28" tabindex="-1"></a><span class="co">#&gt; B4    NaN    NaN    NaN 4.576286</span></span></code></pre></div>
<p>Once the elemental indexes are made, they can be merged together and
then aggregated.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">merge</span>(ms_elemental1, ms_elemental2), pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb34-11"><a href="#cb34-11" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></span></code></pre></div>
<p>A slightly more complex case is when some of the input data are
already a price index. For example, suppose the index values for
businesses B4 and B5 come from some outside process, and are taken as
inputs.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>ms_prices2 <span class="ot">&lt;-</span> <span class="fu">subset</span>(</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>  <span class="fu">as.data.frame</span>(<span class="fu">aggregate</span>(ms_elemental, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)),</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>  level <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;B4&quot;</span>, <span class="st">&quot;B5&quot;</span>)</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>)</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>ms_prices2</span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a><span class="co">#&gt;    period level    value</span></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a><span class="co">#&gt; 7  202001    B4 1.000000</span></span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a><span class="co">#&gt; 8  202001    B5 1.000000</span></span>
<span id="cb35-10"><a href="#cb35-10" tabindex="-1"></a><span class="co">#&gt; 15 202002    B4 1.300724</span></span>
<span id="cb35-11"><a href="#cb35-11" tabindex="-1"></a><span class="co">#&gt; 16 202002    B5 1.300724</span></span>
<span id="cb35-12"><a href="#cb35-12" tabindex="-1"></a><span class="co">#&gt; 23 202003    B4 1.063074</span></span>
<span id="cb35-13"><a href="#cb35-13" tabindex="-1"></a><span class="co">#&gt; 24 202003    B5 1.063074</span></span>
<span id="cb35-14"><a href="#cb35-14" tabindex="-1"></a><span class="co">#&gt; 31 202004    B4 4.576286</span></span>
<span id="cb35-15"><a href="#cb35-15" tabindex="-1"></a><span class="co">#&gt; 32 202004    B5 4.576286</span></span></code></pre></div>
<p>All that is required is to pass the pre-existing indexes to
<code>as_index()</code> to cast them into the correct form. This won’t
affect their values, but will allow them to be merged with the other
elemental indexes, and aggregated.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>ms_elemental2 <span class="ot">&lt;-</span> <span class="fu">as_index</span>(ms_prices2)</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">merge</span>(ms_elemental1, ms_elemental2), pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></span></code></pre></div>
</div>
<div id="aggregating-a-paasche-index" class="section level2">
<h2>Aggregating a Paasche index</h2>
<p>All of the examples so far have used a single set of weights to
aggregate an index. Although this is by far the most common case, there
are situations where the aggregation weights change every period. The
Paasche index is the notable example, as the weights for aggregation are
the current-period revenue shares in each period.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>weights <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>  <span class="at">period =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;202001&quot;</span>, <span class="st">&quot;202002&quot;</span>, <span class="st">&quot;202003&quot;</span>, <span class="st">&quot;202004&quot;</span>), <span class="at">each =</span> <span class="dv">5</span>),</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>  <span class="at">classification =</span> ms_weights<span class="sc">$</span>classification,</span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>  <span class="at">weight =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">20</span></span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>)</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a><span class="fu">head</span>(weights)</span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a><span class="co">#&gt;   period classification weight</span></span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a><span class="co">#&gt; 1 202001             11      1</span></span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a><span class="co">#&gt; 2 202001             11      2</span></span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a><span class="co">#&gt; 3 202001             11      3</span></span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a><span class="co">#&gt; 4 202001             12      4</span></span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a><span class="co">#&gt; 5 202001             12      5</span></span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a><span class="co">#&gt; 6 202002             11      6</span></span></code></pre></div>
<p>The only new tools needed to deal with time-varying weights are the
<code>stack()</code> and <code>unstack()</code> functions.
<code>stack()</code> appends a later index series onto an earlier one
for the same levels, whereas <code>unstack()</code> pulls apart an index
series for many periods into a collection of one-period indexes.</p>
<p>The first step to making a Paasche index is to unstack the elemental
indexes into a list of elemental indexes for each period. (Trying to
make the elemental indexes period-by-period can be dangerous when there
are missing values.)</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>ms_elemental <span class="ot">&lt;-</span> <span class="fu">unstack</span>(ms_elemental)</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>ms_elemental</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a><span class="co">#&gt; $`202001`</span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 1 time periods </span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a><span class="co">#&gt;    202001</span></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="co">#&gt; B1      1</span></span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a><span class="co">#&gt; B2      1</span></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a><span class="co">#&gt; B3      1</span></span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a><span class="co">#&gt; B4    NaN</span></span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a><span class="co">#&gt; $`202002`</span></span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 1 time periods </span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a><span class="co">#&gt;       202002</span></span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a><span class="co">#&gt; B1 0.8949097</span></span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a><span class="co">#&gt; B2       NaN</span></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a><span class="co">#&gt; B3 2.0200036</span></span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a><span class="co">#&gt; B4       NaN</span></span>
<span id="cb38-19"><a href="#cb38-19" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb38-20"><a href="#cb38-20" tabindex="-1"></a><span class="co">#&gt; $`202003`</span></span>
<span id="cb38-21"><a href="#cb38-21" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 1 time periods </span></span>
<span id="cb38-22"><a href="#cb38-22" tabindex="-1"></a><span class="co">#&gt;       202003</span></span>
<span id="cb38-23"><a href="#cb38-23" tabindex="-1"></a><span class="co">#&gt; B1 0.3342939</span></span>
<span id="cb38-24"><a href="#cb38-24" tabindex="-1"></a><span class="co">#&gt; B2       NaN</span></span>
<span id="cb38-25"><a href="#cb38-25" tabindex="-1"></a><span class="co">#&gt; B3 1.6353355</span></span>
<span id="cb38-26"><a href="#cb38-26" tabindex="-1"></a><span class="co">#&gt; B4       NaN</span></span>
<span id="cb38-27"><a href="#cb38-27" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb38-28"><a href="#cb38-28" tabindex="-1"></a><span class="co">#&gt; $`202004`</span></span>
<span id="cb38-29"><a href="#cb38-29" tabindex="-1"></a><span class="co">#&gt; Period-over-period price index for 4 levels over 1 time periods </span></span>
<span id="cb38-30"><a href="#cb38-30" tabindex="-1"></a><span class="co">#&gt;      202004</span></span>
<span id="cb38-31"><a href="#cb38-31" tabindex="-1"></a><span class="co">#&gt; B1      NaN</span></span>
<span id="cb38-32"><a href="#cb38-32" tabindex="-1"></a><span class="co">#&gt; B2 2.770456</span></span>
<span id="cb38-33"><a href="#cb38-33" tabindex="-1"></a><span class="co">#&gt; B3 0.537996</span></span>
<span id="cb38-34"><a href="#cb38-34" tabindex="-1"></a><span class="co">#&gt; B4 4.576286</span></span></code></pre></div>
<p>The second step is to make a sequence of aggregation structures for
each set of weights.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>pias <span class="ot">&lt;-</span> <span class="fu">with</span>(</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>  weights, </span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>  <span class="fu">Map</span>(aggregation_structure, <span class="fu">list</span>(hierarchy), <span class="fu">split</span>(weight, period))</span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>)</span></code></pre></div>
<p>Making the Paasche index for each period is now just a case of
mapping the <code>aggregate()</code> function to each elemental index
and aggregation structure, and then reducing the result with the
<code>stack()</code> function.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>paasche <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>  stack,</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>  <span class="fu">Map</span>(aggregate, ms_elemental, pias, <span class="at">na.rm =</span> <span class="cn">TRUE</span>, <span class="at">r =</span> <span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>)</span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>paasche</span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a><span class="co">#&gt; Aggregate period-over-period price index for 8 levels over 4 time periods </span></span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a><span class="co">#&gt; 1       1 1.3127080 0.5874490 1.3591916</span></span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a><span class="co">#&gt; 11      1 1.3127080 0.5874490 0.8839797</span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a><span class="co">#&gt; 12      1 1.3127080 0.5874490 4.5762862</span></span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 0.8839797</span></span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a><span class="co">#&gt; B2      1 1.3127080 0.5874490 2.7704563</span></span>
<span id="cb40-14"><a href="#cb40-14" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.5379960</span></span>
<span id="cb40-15"><a href="#cb40-15" tabindex="-1"></a><span class="co">#&gt; B4      1 1.3127080 0.5874490 4.5762862</span></span>
<span id="cb40-16"><a href="#cb40-16" tabindex="-1"></a><span class="co">#&gt; B5      1 1.3127080 0.5874490 4.5762862</span></span></code></pre></div>
</div>
<div id="making-a-fisher-index" class="section level2">
<h2>Making a Fisher index</h2>
<p>With a Paasche index in hand, it is now trivial to make a Fisher
index by first making the period-over-period Laspeyres index, and then
doing a simple matrix operation.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a>laspeyres <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(</span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>  stack,</span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a>  <span class="fu">Map</span>(aggregate, ms_elemental, pias[<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)], <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a>)</span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a>fisher <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">as.matrix</span>(laspeyres) <span class="sc">*</span> <span class="fu">as.matrix</span>(paasche))</span>
<span id="cb41-7"><a href="#cb41-7" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" tabindex="-1"></a>fisher</span>
<span id="cb41-9"><a href="#cb41-9" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003   202004</span></span>
<span id="cb41-10"><a href="#cb41-10" tabindex="-1"></a><span class="co">#&gt; 1       1 1.5107763 0.7956890 1.996688</span></span>
<span id="cb41-11"><a href="#cb41-11" tabindex="-1"></a><span class="co">#&gt; 11      1 1.5107763 0.7956890 1.192826</span></span>
<span id="cb41-12"><a href="#cb41-12" tabindex="-1"></a><span class="co">#&gt; 12      1 1.5107763 0.7956890 4.576286</span></span>
<span id="cb41-13"><a href="#cb41-13" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.192826</span></span>
<span id="cb41-14"><a href="#cb41-14" tabindex="-1"></a><span class="co">#&gt; B2      1 1.5107763 0.7956890 2.770456</span></span>
<span id="cb41-15"><a href="#cb41-15" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></span>
<span id="cb41-16"><a href="#cb41-16" tabindex="-1"></a><span class="co">#&gt; B4      1 1.5107763 0.7956890 4.576286</span></span>
<span id="cb41-17"><a href="#cb41-17" tabindex="-1"></a><span class="co">#&gt; B5      1 1.5107763 0.7956890 4.576286</span></span></code></pre></div>
<p>Percent-change contributions can similarly be computed with a matrix
operation.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a>geometric_weights <span class="ot">&lt;-</span> <span class="fu">transmute_weights</span>(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">mapply</span>(</span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a>  \(x, y) <span class="fu">scale_weights</span>(<span class="fu">geometric_weights</span>(<span class="fu">c</span>(x, y))),</span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a>  <span class="fu">as.numeric</span>(laspeyres[<span class="dv">1</span>]),</span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a>  <span class="fu">as.numeric</span>(paasche[<span class="dv">1</span>])</span>
<span id="cb42-7"><a href="#cb42-7" tabindex="-1"></a>)</span>
<span id="cb42-8"><a href="#cb42-8" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" tabindex="-1"></a>laspeyres_contrib <span class="ot">&lt;-</span> <span class="fu">contrib</span>(laspeyres)</span>
<span id="cb42-10"><a href="#cb42-10" tabindex="-1"></a>paasche_contrib <span class="ot">&lt;-</span> <span class="fu">contrib</span>(paasche)</span>
<span id="cb42-11"><a href="#cb42-11" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" tabindex="-1"></a>fisher_contrib <span class="ot">&lt;-</span> w[<span class="dv">1</span>, <span class="fu">col</span>(laspeyres_contrib)] <span class="sc">*</span> laspeyres_contrib <span class="sc">+</span></span>
<span id="cb42-13"><a href="#cb42-13" tabindex="-1"></a>  w[<span class="dv">2</span>, <span class="fu">col</span>(paasche_contrib)] <span class="sc">*</span> paasche_contrib</span>
<span id="cb42-14"><a href="#cb42-14" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" tabindex="-1"></a>fisher_contrib</span>
<span id="cb42-16"><a href="#cb42-16" tabindex="-1"></a><span class="co">#&gt;    202001      202002      202003       202004</span></span>
<span id="cb42-17"><a href="#cb42-17" tabindex="-1"></a><span class="co">#&gt; 1       0  0.00000000  0.00000000  0.000000000</span></span>
<span id="cb42-18"><a href="#cb42-18" tabindex="-1"></a><span class="co">#&gt; 10      0 -0.13327742  0.17296129 -0.131946938</span></span>
<span id="cb42-19"><a href="#cb42-19" tabindex="-1"></a><span class="co">#&gt; 11      0  0.00000000          NA  0.039533034</span></span>
<span id="cb42-20"><a href="#cb42-20" tabindex="-1"></a><span class="co">#&gt; 12      0  0.00000000          NA  0.880561300</span></span>
<span id="cb42-21"><a href="#cb42-21" tabindex="-1"></a><span class="co">#&gt; 2      NA          NA -0.42962331  0.000000000</span></span>
<span id="cb42-22"><a href="#cb42-22" tabindex="-1"></a><span class="co">#&gt; 3       0 -0.04756479          NA           NA</span></span>
<span id="cb42-23"><a href="#cb42-23" tabindex="-1"></a><span class="co">#&gt; 4       0          NA          NA -0.012019870</span></span>
<span id="cb42-24"><a href="#cb42-24" tabindex="-1"></a><span class="co">#&gt; 5       0          NA          NA  0.062419211</span></span>
<span id="cb42-25"><a href="#cb42-25" tabindex="-1"></a><span class="co">#&gt; 6       0          NA          NA  0.282471798</span></span>
<span id="cb42-26"><a href="#cb42-26" tabindex="-1"></a><span class="co">#&gt; 7       0  0.78379264 -0.13008203 -0.018866231</span></span>
<span id="cb42-27"><a href="#cb42-27" tabindex="-1"></a><span class="co">#&gt; 8       0  0.02893842  0.11116498 -0.006388331</span></span>
<span id="cb42-28"><a href="#cb42-28" tabindex="-1"></a><span class="co">#&gt; 9       0 -0.12111255  0.07126804 -0.099076370</span></span></code></pre></div>
<p>The despite being a matrix, the resulting Fisher index can be chained
just like any other index.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="fu">chain</span>(fisher)</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a><span class="co">#&gt; Fixed-base price index for 8 levels over 4 time periods </span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a><span class="co">#&gt; 1       1 1.5107763 1.2021080 2.4002342</span></span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a><span class="co">#&gt; 11      1 1.5107763 1.2021080 1.4339054</span></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a><span class="co">#&gt; 12      1 1.5107763 1.2021080 5.5011904</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.3568492</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a><span class="co">#&gt; B2      1 1.5107763 1.2021080 3.3303878</span></span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a><span class="co">#&gt; B4      1 1.5107763 1.2021080 5.5011904</span></span>
<span id="cb43-11"><a href="#cb43-11" tabindex="-1"></a><span class="co">#&gt; B5      1 1.5107763 1.2021080 5.5011904</span></span></code></pre></div>
<p>A chained Fisher index can also be made by first chaining the
Laspyeres and Paasche indexes, then taking the geometric mean.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="fu">as.matrix</span>(<span class="fu">chain</span>(laspeyres)) <span class="sc">*</span> <span class="fu">as.matrix</span>(<span class="fu">chain</span>(paasche)))</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="co">#&gt;    202001    202002    202003    202004</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a><span class="co">#&gt; 1       1 1.5107763 1.2021080 2.4002342</span></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a><span class="co">#&gt; 11      1 1.5107763 1.2021080 1.4339054</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a><span class="co">#&gt; 12      1 1.5107763 1.2021080 5.5011904</span></span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.3568492</span></span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a><span class="co">#&gt; B2      1 1.5107763 1.2021080 3.3303878</span></span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a><span class="co">#&gt; B4      1 1.5107763 1.2021080 5.5011904</span></span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a><span class="co">#&gt; B5      1 1.5107763 1.2021080 5.5011904</span></span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
