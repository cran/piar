<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Making price indexes</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Making price indexes</h1>



<p>Most price indexes are made with a two-step procedure, where period-over-period <em>elemental indexes</em> are calculated for a collection of <em>elemental aggregates</em> at each point in time, and then aggregated according to a <em>price index aggregation structure</em>. These indexes can then be chained together to form a time series that gives the evolution of prices with respect to a fixed base period. The <strong>piar</strong> package contains a collections of functions that revolve around this work flow, making it easy to build standard price indexes in <strong>R</strong>.</p>
<p>The purpose of this vignette is to give several extended examples of how to use the functions in this package to make different types of price indexes. This should serve both as a introduction to the functionality in <strong>piar</strong>, and a reference for solving specific index-number problems.</p>
<div id="matched-sample-index" class="section level2">
<h2>Matched-sample index</h2>
<p>The first example covers calculating a matched-sample index, where a fixed set of businesses each provide prices for a collection of products over time. The products reported by a businesses can change over time, but the set of businesses is fixed for the duration of the sample. Each businesses has a weight that is established when the sample is drawn, and represents a particular segment of the economy.</p>
<p>The usual approach for calculating a matched-sample index starts by computing the elemental index for each business as an equally-weighted geometric mean of price relatives (i.e., a Jevons index). From there, index values for different segments of the economy are calculated as an arithmetic mean of the elemental indexes, using the businesses-level weights (either a Young or Lowe index, depending how the weights are constructed).</p>
<p>The <code>ms_prices</code> dataset has price data for five businesses over four quarters, and the <code>ms_weights</code> dataset has the weight data. Note that these data have fairly realistic patterns of missing data.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(piar)</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">head</span>(ms_prices)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">#&gt;   period business product price</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">#&gt; 1 202001       B1       1  1.14</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">#&gt; 2 202001       B1       2    NA</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">#&gt; 3 202001       B1       3  6.09</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">#&gt; 4 202001       B2       4  6.23</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">#&gt; 5 202001       B2       5  8.61</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">#&gt; 6 202001       B2       6  6.40</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14">ms_weights</a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">#&gt;   business classification weight</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">#&gt; 1       B1             11    553</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">#&gt; 2       B2             11    646</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">#&gt; 3       B3             11    312</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">#&gt; 4       B4             12    622</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">#&gt; 5       B5             12    330</span></a></code></pre></div>
<p>The <code>elemental_index()</code> function makes, well, elemental indexes, using information on price relatives, elemental aggregates (businesses), and time periods (quarters). By default it makes a Jevons index, but any bilateral generalized-mean index is possible. The only wrinkle is that price data here are in levels, and not relatives, but the <code>price_relative()</code> function can make the necessary conversion.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">relative &lt;-<span class="st"> </span><span class="kw">with</span>(ms_prices, <span class="kw">price_relative</span>(price, period, product))</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">(ms_epr &lt;-<span class="st"> </span><span class="kw">with</span>(ms_prices, <span class="kw">elemental_index</span>(relative, period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)))</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">#&gt; B2      1       NaN       NaN 2.770456</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></a></code></pre></div>
<p>(Homogeneous elemental aggregates often leads to unit-value elemental indexes that are not based on price relatives. These cases can be dealt with by first aggregating prices for each elemental aggregate, <code>aggregate(price ~ period + product, ms_prices, mean)</code>, at each point in time with an arithmetic mean, then forming price relatives to feed into <code>elemental_index()</code>.)</p>
<p>As with most functions in <strong>R</strong>, missing values are contagious by default in <strong>piar</strong>. Setting <code>na.rm = TRUE</code> in <code>elemental_index()</code> means that missing price relatives are ignored, which is equivalent to imputing these missing relatives with the value of the elemental index for the respective businesses (i.e., parental or overall mean imputation). Other types of imputation are possible, and are the topic of a subsequent example.</p>
<p>The <code>elemental_index()</code> function returns a special index object, and there are a number of methods for working with these objects. Probably the most useful of these methods allows the resulting elemental indexes to be extracted like a matrix, even though it’s not a matrix. (Note that there are only indexes for four businesses, not five, because the fifth business never reports any prices; an elemental index can be made for this business with a small change to the call to <code>elemental_index()</code>.)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">ms_epr[, <span class="st">&quot;202004&quot;</span>]</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">#&gt;      202004</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">#&gt; B1      NaN</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">#&gt; B2 2.770456</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">#&gt; B3 0.537996</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">#&gt; B4 4.576286</span></a>
<a class="sourceLine" id="cb3-7" title="7">ms_epr[<span class="st">&quot;B1&quot;</span>, ]</a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">#&gt;    202001    202002    202003 202004</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">#&gt; B1      1 0.8949097 0.3342939    NaN</span></a></code></pre></div>
<p>With the elemental indexes out of the way, it’s time to make a price-index aggregation structure that maps each business to its position in the aggregation hierarchy. The only hiccup is unpacking the digit-wise classification for each businesses that defines the hierarchy. That’s the job of the <code>expand_classification()</code> function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">hierarchy &lt;-<span class="st"> </span><span class="kw">with</span>(ms_weights, <span class="kw">c</span>(<span class="kw">expand_classification</span>(classification), <span class="kw">list</span>(business)))</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">pias &lt;-<span class="st"> </span><span class="kw">aggregation_structure</span>(hierarchy, ms_weights<span class="op">$</span>weight)</a></code></pre></div>
<p>It is now simple to aggregate the elemental indexes according to this aggregation structure with the <code>aggregate()</code> function. As with the elemental indexes, missing values are ignored by setting <code>na.rm = TRUE</code>, which is equivalent to parentally imputing missing values. Note that, unlike the elemental indexes, missing values are filled in to ensure the index can be chained over time.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">(ms_index &lt;-<span class="st"> </span><span class="kw">aggregate</span>(ms_epr, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></a></code></pre></div>
<p>Although simple, this example covers the core functionality of <strong>piar</strong>. The remaining examples in the vignette build on this one by adding complexities that often arise in practice.</p>
</div>
<div id="chaining" class="section level2">
<h2>Chaining</h2>
<p>The <code>elemental_index()</code> function makes period-over-period elemental indexes by default, which can then be aggregated to make a period-over-period index. Chaining an index is the process of taking the cumulative product of each of these period-over-period indexes to make a time series that compares prices to a fixed base period.</p>
<p>The <code>chain()</code> function can be used to chain the values in an index object.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">(ms_index_chained &lt;-<span class="st"> </span><span class="kw">chain</span>(ms_index))</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></a></code></pre></div>
<p>This gives almost the same result as directly manipulating the index as a matrix, except that the former returns an index object (not a matrix).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">t</span>(<span class="kw">apply</span>(<span class="kw">as.matrix</span>(ms_index), <span class="dv">1</span>, cumprod))</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></a></code></pre></div>
<p>Chained indexes often need be to rebased, and this can be done with the <code>rebase()</code> function. For example, rebasing the index so that 202004 is the base period just requires dividing the chained index by the slice for 202004.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">rebase</span>(ms_index_chained, ms_index_chained[, <span class="st">&quot;202004&quot;</span>])</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">#&gt;       202001    202002    202003 202004</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">#&gt; 1  0.2644428 0.3439671 0.3656626      1</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">#&gt; 11 0.4593084 0.5974334 0.6351161      1</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">#&gt; 12 0.1580295 0.2055527 0.2185178      1</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="co">#&gt; B1 2.1229774 1.8998731 0.6351161      1</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">#&gt; B2 0.2610357 0.3395354 0.3609514      1</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">#&gt; B3 0.5626806 1.1366169 1.8587499      1</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="co">#&gt; B4 0.1580295 0.2055527 0.2185178      1</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="co">#&gt; B5 0.1580295 0.2055527 0.2185178      1</span></a></code></pre></div>
<p>In some cases the base period is the average of several periods; setting the base period to the second half of 2020 just requires dividing by the row-wise mean.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">rebase</span>(ms_index_chained, <span class="kw">rowMeans</span>(<span class="kw">as.matrix</span>(ms_index_chained)[, <span class="kw">c</span>(<span class="st">&quot;202003&quot;</span>, <span class="st">&quot;202004&quot;</span>)]))</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">#&gt;       202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co">#&gt; 1  0.3872740 0.5037366 0.5355095 1.4644905</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">#&gt; 11 0.5618052 0.7307535 0.7768452 1.2231548</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">#&gt; 12 0.2593798 0.3373815 0.3586616 1.6413384</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="co">#&gt; B1 2.5967299 2.3238388 0.7768452 1.2231548</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="co">#&gt; B2 0.3836077 0.4989677 0.5304398 1.4695602</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">#&gt; B3 0.3936550 0.7951845 1.3003935 0.6996065</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="co">#&gt; B4 0.2593798 0.3373815 0.3586616 1.6413384</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="co">#&gt; B5 0.2593798 0.3373815 0.3586616 1.6413384</span></a></code></pre></div>
</div>
<div id="multi-dimensional-aggregation-structures" class="section level2">
<h2>Multi-dimensional aggregation structures</h2>
<p>Price indexes are often aggregated over multiple dimensions. Matched sample indexes that use sequential Poisson sampling are a good example, as there are usually take-all and take-some strata in addition to, say, an industry classification.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">(ms_weights &lt;-<span class="st"> </span><span class="kw">transform</span>(ms_weights, <span class="dt">stratum =</span> <span class="kw">c</span>(<span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TA&quot;</span>, <span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TS&quot;</span>, <span class="st">&quot;TS&quot;</span>)))</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">#&gt;   business classification weight stratum</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">#&gt; 1       B1             11    553      TS</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">#&gt; 2       B2             11    646      TA</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">#&gt; 3       B3             11    312      TS</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">#&gt; 4       B4             12    622      TS</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">#&gt; 5       B5             12    330      TS</span></a></code></pre></div>
<p>The easiest way to deal with multiple digit-wise classifications is to turn them into one classification. In this example the “stratum” dimension comes before the “classification” dimension for the purposes of parental imputation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">(classification_sps &lt;-<span class="st"> </span><span class="kw">with</span>(ms_weights, <span class="kw">paste0</span>(classification, stratum)))</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">#&gt; [1] &quot;11TS&quot; &quot;11TA&quot; &quot;11TS&quot; &quot;12TS&quot; &quot;12TS&quot;</span></a></code></pre></div>
<p>This classification can be expanded with the <code>expand_classification()</code> function as before, just with an extra instruction to say that the last “digit” in the classification is two characters wide, not one.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">(classification_sps &lt;-<span class="st"> </span><span class="kw">expand_classification</span>(classification_sps, <span class="dt">width =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">#&gt; [[1]]</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">#&gt; [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot;</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">#&gt; [[2]]</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">#&gt; [1] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot;</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">#&gt; [[3]]</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">#&gt; [1] &quot;11TS&quot; &quot;11TA&quot; &quot;11TS&quot; &quot;12TS&quot; &quot;12TS&quot;</span></a>
<a class="sourceLine" id="cb12-10" title="10">pias_sps &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb12-11" title="11">  ms_weights, </a>
<a class="sourceLine" id="cb12-12" title="12">  <span class="kw">aggregation_structure</span>(<span class="kw">c</span>(classification_sps, <span class="kw">list</span>(business)), weight)</a>
<a class="sourceLine" id="cb12-13" title="13">)</a></code></pre></div>
<p>The elemental indexes can now be aggregated according to this new aggregation structure.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">aggregate</span>(ms_epr, pias_sps, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">#&gt;      202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">#&gt; 1         1 1.3007239 1.0630743 2.684412</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">#&gt; 11        1 1.3007239 1.0630743 1.492443</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co">#&gt; 12        1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">#&gt; 11TA      1 1.3007239 1.0630743 2.770456</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co">#&gt; 11TS      1 1.3007239 1.0630743 0.537996</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="co">#&gt; 12TS      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co">#&gt; B1        1 0.8949097 0.3342939 0.537996</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="co">#&gt; B2        1 1.3007239 1.0630743 2.770456</span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="co">#&gt; B3        1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="co">#&gt; B4        1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="co">#&gt; B5        1 1.3007239 1.0630743 4.576286</span></a></code></pre></div>
</div>
<div id="non-parental-imputation-during-aggregation" class="section level2">
<h2>Non-parental imputation during aggregation</h2>
<p>Parental imputation is the usual way to impute missing index values during aggregation, and it is simple to do with <code>aggregate()</code>. In some cases, however, a business-level index may get imputed with the value for, say, another business, rather than for an entire group of businesses. The simplest way to do this sort of imputation is to alter the elemental indexes prior to aggregation. It is also possible to augment the aggregation structure with an imputation layer, but this is more complex.</p>
<p>Suppose that missing index values for business B2 should be imputed as 1, rather than the value for group 11. This replacement can be done as if the index was a matrix.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">ms_epr2 &lt;-<span class="st"> </span>ms_epr</a>
<a class="sourceLine" id="cb14-2" title="2">ms_epr2[<span class="st">&quot;B2&quot;</span>, <span class="dv">2</span><span class="op">:</span><span class="dv">3</span>] &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb14-3" title="3">ms_epr2</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="co">#&gt; B2      1 1.0000000 1.0000000 2.770456</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></a></code></pre></div>
<p>The index can now be aggregated as usual.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">aggregate</span>(ms_epr2, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="co">#&gt; 1       1 1.1721550 1.0400686 2.626560</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co">#&gt; 11      1 1.1721550 1.0400686 1.398142</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co">#&gt; 12      1 1.1721550 1.0400686 4.576286</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.398142</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co">#&gt; B2      1 1.0000000 1.0000000 2.770456</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="co">#&gt; B4      1 1.1721550 1.0400686 4.576286</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="co">#&gt; B5      1 1.1721550 1.0400686 4.576286</span></a></code></pre></div>
</div>
<div id="alternate-index-number-formulas" class="section level2">
<h2>Alternate index-number formulas</h2>
<p>By default, the <code>elemental_index()</code> function calculates a Jevons index. Although this is the standard index-number formula for making elemental indexes, many other types of index-numbers are possible. The Carli index (equally-weighted arithmetic mean of price relatives) is the main competitor to the Jevons, and requires specifying the order of the index <code>r</code> when calling <code>elemental_index()</code>. An order of 1 corresponds to an arithmetic mean.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">with</span>(ms_prices, <span class="kw">elemental_index</span>(relative, period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">r =</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co">#&gt;    202001     202002    202003   202004</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">#&gt; B1      1  0.8949097 0.3342939      NaN</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co">#&gt; B2      1        NaN       NaN 5.155942</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co">#&gt; B3      1 23.7480455 2.4900997 0.607197</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">#&gt; B4    NaN        NaN       NaN 9.368610</span></a></code></pre></div>
<p>The Coggeshall index (equally-weighted harmonic mean of price relatives) is another competitor to the Jevons, but is seldom used in practice. Despite it being more exotic, it is just as easy to make by specifying an order <code>r</code> of -1.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">with</span>(ms_prices, <span class="kw">elemental_index</span>(relative, period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">r =</span> <span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">#&gt; B1      1 0.8949097 0.3342939       NaN</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">#&gt; B2      1       NaN       NaN 1.7205750</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co">#&gt; B3      1 0.6591433 0.8185743 0.4746769</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co">#&gt; B4    NaN       NaN       NaN 2.2353790</span></a></code></pre></div>
<p>The type of mean used to aggregate elemental indexes can be controlled in the same way in the call to <code>aggregate()</code>. The default makes an arithmetic index, but any type of generalized-mean index is possible.</p>
<p>Many superlative indexes can be made by supplying unequal and (usually) time-varying weights when making the elemental indexes. These weights often come from information on quantities.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" title="1">ms_prices2 &lt;-<span class="st"> </span><span class="kw">transform</span>(ms_prices, <span class="dt">quantity =</span> <span class="dv">10</span> <span class="op">-</span><span class="st"> </span>price)</a></code></pre></div>
<p>The Tornqvist index is a popular superlative index-number formula, using average period-over-period value shares as the weights in a geometric mean. The only tricky part is making the weights from data on prices and quantities.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">library</span>(gpindex)</a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3">tw &lt;-<span class="st"> </span><span class="kw">grouped</span>(<span class="kw">index_weights</span>(<span class="st">&quot;Tornqvist&quot;</span>))</a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5">ms_prices2[<span class="kw">c</span>(<span class="st">&quot;back_price&quot;</span>, <span class="st">&quot;back_quantity&quot;</span>)] &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="st">  </span>ms_prices2[<span class="kw">back_period</span>(ms_prices2<span class="op">$</span>period, ms_prices2<span class="op">$</span>product), <span class="kw">c</span>(<span class="st">&quot;price&quot;</span>, <span class="st">&quot;quantity&quot;</span>)]</a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8">ms_prices2 &lt;-<span class="st"> </span><span class="kw">na.omit</span>(ms_prices2) <span class="co"># can&#39;t have NAs for Tornqvist weights</span></a>
<a class="sourceLine" id="cb19-9" title="9"></a>
<a class="sourceLine" id="cb19-10" title="10">ms_prices2<span class="op">$</span>weight &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb19-11" title="11">  ms_prices2,</a>
<a class="sourceLine" id="cb19-12" title="12">  <span class="kw">tw</span>(price, back_price, quantity, back_quantity, <span class="dt">group =</span> <span class="kw">interaction</span>(period, business))</a>
<a class="sourceLine" id="cb19-13" title="13">)</a></code></pre></div>
<p>As <code>elemental_index()</code> makes a geometric index by default, all that is needed to make a Tornqvist index is to provide the weights.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">with</span>(ms_prices2, <span class="kw">elemental_index</span>(price <span class="op">/</span><span class="st"> </span>back_price, period, business, weight))</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="co">#&gt; B2      1       NaN       NaN 2.165152</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">#&gt; B3      1 0.9520982 1.5913929 0.542372</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">#&gt; B4    NaN       NaN       NaN 5.904237</span></a></code></pre></div>
</div>
<div id="quote-contributions" class="section level2">
<h2>Quote contributions</h2>
<p>It’s often convenient to decompose an index into the (additive) contribution of each price relative, also known as the quote contributions. This can be done with the same work flow as in the previous examples, specifying <code>contrib = TRUE</code> when calling <code>elemental_index()</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" title="1">ms_epr &lt;-<span class="st"> </span><span class="kw">with</span>(ms_prices, <span class="kw">elemental_index</span>(relative, period, business, <span class="dt">contrib =</span> <span class="ot">TRUE</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a></code></pre></div>
<p>As with index values, quote contributions for a given level of the index can be extracted as a matrix.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">contrib</span>(ms_epr)</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="co">#&gt;   202001     202002     202003 202004</span></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="co">#&gt; 1      0  0.0000000  0.0000000      0</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="co">#&gt; 2     NA         NA -0.6657061      0</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="co">#&gt; 3      0 -0.1050903         NA     NA</span></a></code></pre></div>
<p>Aggregating the elemental indexes automatically aggregates quote contributions, so no extra steps are needed after the elemental indexes are made.</p>
</div>
<div id="updating-a-basket" class="section level2">
<h2>Updating a basket</h2>
<p>The functions in <strong>piar</strong> are all designed to work within a “basket”, which is a fancy way of saying within a given aggregation structure. Over time, however, aggregation structures change as the weights used to aggregate an index get updated, and new samples of businesses are drawn. The general approach to keep the time series going is to “chain” the index across baskets.</p>
<p>It is easier to see how to chain an index over time with a simple example that just splits the <code>ms_prices</code> data in two.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" title="1">ms_prices1 &lt;-<span class="st"> </span><span class="kw">subset</span>(ms_prices, period <span class="op">&lt;=</span><span class="st"> &quot;202003&quot;</span>)</a>
<a class="sourceLine" id="cb23-2" title="2">ms_prices2 &lt;-<span class="st"> </span><span class="kw">subset</span>(ms_prices, period <span class="op">&gt;=</span><span class="st"> &quot;202003&quot;</span>)</a></code></pre></div>
<p>The index for the first basket can be calculate as usual.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1">ms_epr1 &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb24-2" title="2">  ms_prices1, </a>
<a class="sourceLine" id="cb24-3" title="3">  <span class="kw">elemental_index</span>(<span class="kw">price_relative</span>(price, period, product), period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb24-4" title="4">)</a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6">(ms_index1 &lt;-<span class="st"> </span><span class="kw">aggregate</span>(ms_epr1, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb24-7" title="7"><span class="co">#&gt;    202001    202002    202003</span></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="co">#&gt; 1       1 1.3007239 1.0630743</span></a>
<a class="sourceLine" id="cb24-9" title="9"><span class="co">#&gt; 11      1 1.3007239 1.0630743</span></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="co">#&gt; 12      1 1.3007239 1.0630743</span></a>
<a class="sourceLine" id="cb24-11" title="11"><span class="co">#&gt; B1      1 0.8949097 0.3342939</span></a>
<a class="sourceLine" id="cb24-12" title="12"><span class="co">#&gt; B2      1 1.3007239 1.0630743</span></a>
<a class="sourceLine" id="cb24-13" title="13"><span class="co">#&gt; B3      1 2.0200036 1.6353355</span></a>
<a class="sourceLine" id="cb24-14" title="14"><span class="co">#&gt; B4      1 1.3007239 1.0630743</span></a>
<a class="sourceLine" id="cb24-15" title="15"><span class="co">#&gt; B5      1 1.3007239 1.0630743</span></a></code></pre></div>
<p>Nothing special needs to be done to make the elemental indexes for the new basket, but it’s easier to remove the index values of 1 for quarter 3 2020.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" title="1">ms_epr2 &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="kw">subset</span>(<span class="kw">transform</span>(ms_prices2, <span class="dt">rel =</span> <span class="kw">price_relative</span>(price, period, product)), period <span class="op">&gt;</span><span class="st"> &quot;202003&quot;</span>),</a>
<a class="sourceLine" id="cb25-3" title="3">  <span class="kw">elemental_index</span>(rel, period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb25-4" title="4">)</a></code></pre></div>
<p>Aggregating these elemental indexes, however, requires an aggregation structure. The results of the first example can be reproduced by simply “price updating” the original weights, then building the aggregation structure as usual.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1">(ms_index2 &lt;-<span class="st"> </span><span class="kw">aggregate</span>(ms_epr2, <span class="kw">update</span>(pias, ms_index1), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="co">#&gt;      202004</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="co">#&gt; 1  2.734761</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="co">#&gt; 11 1.574515</span></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">#&gt; 12 4.576286</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="co">#&gt; B1 1.574515</span></a>
<a class="sourceLine" id="cb26-7" title="7"><span class="co">#&gt; B2 2.770456</span></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">#&gt; B3 0.537996</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">#&gt; B4 4.576286</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">#&gt; B5 4.576286</span></a></code></pre></div>
<p>This produces two sets of period-over-period indexes that can be stacked together and then chained.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">chain</span>(<span class="kw">stack</span>(ms_index1, ms_index2))</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">#&gt; 1       1 1.3007239 1.3827662 3.7815355</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="co">#&gt; 11      1 1.3007239 1.3827662 2.1771866</span></a>
<a class="sourceLine" id="cb27-5" title="5"><span class="co">#&gt; 12      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.2991629 0.4710366</span></a>
<a class="sourceLine" id="cb27-7" title="7"><span class="co">#&gt; B2      1 1.3007239 1.3827662 3.8308934</span></a>
<a class="sourceLine" id="cb27-8" title="8"><span class="co">#&gt; B3      1 2.0200036 3.3033836 1.7772072</span></a>
<a class="sourceLine" id="cb27-9" title="9"><span class="co">#&gt; B4      1 1.3007239 1.3827662 6.3279338</span></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="co">#&gt; B5      1 1.3007239 1.3827662 6.3279338</span></a></code></pre></div>
</div>
<div id="carry-forward-imputation" class="section level2">
<h2>Carry-forward imputation</h2>
<p>The previous examples used parental imputation to both impute missing price relatives when calculating the elemental indexes, and to impute missing elemental indexes during aggregation. Another common imputation strategy when making elemental indexes is to carry forward the previous price to impute for missing prices, and parentally impute missing elemental indexes during aggregation. As the <code>elemental_index()</code> function accepts price relatives as its input, other types of imputations can be done prior to passing price relatives to this function.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1">(ms_epr2 &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb28-2" title="2">  ms_prices, </a>
<a class="sourceLine" id="cb28-3" title="3">  <span class="kw">elemental_index</span>(<span class="kw">price_relative</span>(<span class="kw">carry_forward</span>(price, period, product), period, product), </a>
<a class="sourceLine" id="cb28-4" title="4">                  period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb28-5" title="5">  )</a>
<a class="sourceLine" id="cb28-6" title="6">)</a>
<a class="sourceLine" id="cb28-7" title="7"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb28-8" title="8"><span class="co">#&gt; B1      1 0.8949097 0.5781816 1.000000</span></a>
<a class="sourceLine" id="cb28-9" title="9"><span class="co">#&gt; B2      1 1.0000000 0.1777227 2.770456</span></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb28-11" title="11"><span class="co">#&gt; B4    NaN       NaN       NaN 4.576286</span></a></code></pre></div>
<p>Aggregation follows the same steps as in the previous examples, with missing values set to be ignored in order to parentally impute missing elemental indexes.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" title="1">(ms_index &lt;-<span class="st"> </span><span class="kw">aggregate</span>(ms_epr2, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb29-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co">#&gt; 1       1 1.1721550 0.8082981 2.2653614</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="co">#&gt; 11      1 1.1721550 0.8082981 0.8093718</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="co">#&gt; 12      1 1.1721550 0.8082981 4.5762862</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.5781816 1.0000000</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="co">#&gt; B2      1 1.0000000 0.1777227 2.7704563</span></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.5379960</span></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="co">#&gt; B4      1 1.1721550 0.8082981 4.5762862</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="co">#&gt; B5      1 1.1721550 0.8082981 4.5762862</span></a></code></pre></div>
</div>
<div id="calculating-an-index-from-multiple-sources" class="section level2">
<h2>Calculating an index from multiple sources</h2>
<p>All of the examples so far have built an index from a single source of price data. In many cases the elemental indexes are built from multiple sources of data, either because no single source of data has the necessary coverage, or different index-number formulas are employed for different elemental aggregates.</p>
<p>It is straightforward to merge index objects together, provided they’re for the same time periods. To keep the example simple, suppose that <code>ms_prices</code> is split in two.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1">ms_prices1 &lt;-<span class="st"> </span><span class="kw">subset</span>(ms_prices, business <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;B1&quot;</span>, <span class="st">&quot;B2&quot;</span>, <span class="st">&quot;B3&quot;</span>))</a>
<a class="sourceLine" id="cb30-2" title="2">ms_prices2 &lt;-<span class="st"> </span><span class="kw">subset</span>(ms_prices, business <span class="op">==</span><span class="st"> &quot;B4&quot;</span>)</a></code></pre></div>
<p>Elemental indexes can be made for both groups separately with the usual recipe. Note that there is no data for business B4 in the first two periods, so the time periods need to be made explicit.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" title="1">ms_epr1 &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb31-2" title="2">  ms_prices1, </a>
<a class="sourceLine" id="cb31-3" title="3">  <span class="kw">elemental_index</span>(<span class="kw">price_relative</span>(price, period, product), period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb31-4" title="4">)</a>
<a class="sourceLine" id="cb31-5" title="5">ms_epr1</a>
<a class="sourceLine" id="cb31-6" title="6"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="co">#&gt; B1      1 0.8949097 0.3342939      NaN</span></a>
<a class="sourceLine" id="cb31-8" title="8"><span class="co">#&gt; B2      1       NaN       NaN 2.770456</span></a>
<a class="sourceLine" id="cb31-9" title="9"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb31-10" title="10">ms_epr2 &lt;-<span class="st"> </span><span class="kw">with</span>(</a>
<a class="sourceLine" id="cb31-11" title="11">  <span class="kw">transform</span>(ms_prices2, <span class="dt">period =</span> <span class="kw">factor</span>(period, <span class="dt">levels =</span> <span class="kw">time</span>(ms_epr1))), </a>
<a class="sourceLine" id="cb31-12" title="12">  <span class="kw">elemental_index</span>(<span class="kw">price_relative</span>(price, period, product), period, business, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb31-13" title="13">)</a>
<a class="sourceLine" id="cb31-14" title="14">ms_epr2</a>
<a class="sourceLine" id="cb31-15" title="15"><span class="co">#&gt;    202001 202002 202003   202004</span></a>
<a class="sourceLine" id="cb31-16" title="16"><span class="co">#&gt; B4    NaN    NaN    NaN 4.576286</span></a></code></pre></div>
<p>Once the elemental indexes are made, they can be merged together and then aggregated.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">aggregate</span>(<span class="kw">merge</span>(ms_epr1, ms_epr2), pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></a>
<a class="sourceLine" id="cb32-7" title="7"><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></a>
<a class="sourceLine" id="cb32-8" title="8"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb32-9" title="9"><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb32-10" title="10"><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></a></code></pre></div>
<p>A slightly more complex case is when some of the input data are already a price index. For example, suppose the index values for businesses B4 and B5 come from some outside process, and are taken as inputs.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" title="1">ms_prices2 &lt;-<span class="st"> </span><span class="kw">subset</span>(</a>
<a class="sourceLine" id="cb33-2" title="2">  <span class="kw">as.data.frame</span>(<span class="kw">aggregate</span>(ms_epr, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)),</a>
<a class="sourceLine" id="cb33-3" title="3">  level <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;B4&quot;</span>, <span class="st">&quot;B5&quot;</span>)</a>
<a class="sourceLine" id="cb33-4" title="4">)</a>
<a class="sourceLine" id="cb33-5" title="5">ms_prices2</a>
<a class="sourceLine" id="cb33-6" title="6"><span class="co">#&gt;    period level    value</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="co">#&gt; 7  202001    B4 1.000000</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="co">#&gt; 8  202001    B5 1.000000</span></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="co">#&gt; 15 202002    B4 1.300724</span></a>
<a class="sourceLine" id="cb33-10" title="10"><span class="co">#&gt; 16 202002    B5 1.300724</span></a>
<a class="sourceLine" id="cb33-11" title="11"><span class="co">#&gt; 23 202003    B4 1.063074</span></a>
<a class="sourceLine" id="cb33-12" title="12"><span class="co">#&gt; 24 202003    B5 1.063074</span></a>
<a class="sourceLine" id="cb33-13" title="13"><span class="co">#&gt; 31 202004    B4 4.576286</span></a>
<a class="sourceLine" id="cb33-14" title="14"><span class="co">#&gt; 32 202004    B5 4.576286</span></a></code></pre></div>
<p>All that is required is to pass the pre-existing indexes to <code>elemental_index()</code> to cast it into the correct form. This won’t affect their values, but will allow them to be merged with the other elemental indexes, and aggregated.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" title="1">ms_epr2 &lt;-<span class="st"> </span><span class="kw">with</span>(ms_prices2, <span class="kw">elemental_index</span>(value, period, level))</a>
<a class="sourceLine" id="cb34-2" title="2"><span class="kw">aggregate</span>(<span class="kw">merge</span>(ms_epr1, ms_epr2), pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="co">#&gt; 1       1 1.3007239 1.0630743 2.734761</span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">#&gt; 11      1 1.3007239 1.0630743 1.574515</span></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">#&gt; 12      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.574515</span></a>
<a class="sourceLine" id="cb34-8" title="8"><span class="co">#&gt; B2      1 1.3007239 1.0630743 2.770456</span></a>
<a class="sourceLine" id="cb34-9" title="9"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb34-10" title="10"><span class="co">#&gt; B4      1 1.3007239 1.0630743 4.576286</span></a>
<a class="sourceLine" id="cb34-11" title="11"><span class="co">#&gt; B5      1 1.3007239 1.0630743 4.576286</span></a></code></pre></div>
</div>
<div id="paasche-index" class="section level2">
<h2>Paasche index</h2>
<p>All of the examples so far have used a single set of weights to aggregate an index. Although this is by far the most common case, there are situations where the weights to aggregate change every period. The Paasche index is the notable example, as the weights for aggregation are the current-period revenue shares in each period.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" title="1">weights &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">period =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;202001&quot;</span>, <span class="st">&quot;202002&quot;</span>, <span class="st">&quot;202003&quot;</span>, <span class="st">&quot;202004&quot;</span>), <span class="dt">each =</span> <span class="dv">5</span>),</a>
<a class="sourceLine" id="cb35-2" title="2">                      <span class="dt">classification =</span> ms_weights<span class="op">$</span>classification,</a>
<a class="sourceLine" id="cb35-3" title="3">                      <span class="dt">weight =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb35-4" title="4"><span class="kw">head</span>(weights)</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co">#&gt;   period classification weight</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="co">#&gt; 1 202001             11      1</span></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="co">#&gt; 2 202001             11      2</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="co">#&gt; 3 202001             11      3</span></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="co">#&gt; 4 202001             12      4</span></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="co">#&gt; 5 202001             12      5</span></a>
<a class="sourceLine" id="cb35-11" title="11"><span class="co">#&gt; 6 202002             11      6</span></a></code></pre></div>
<p>The only new tools needed to deal with time-varying weights are the <code>stack()</code> and <code>unstack()</code> functions. <code>stack()</code> appends a later index series onto an earlier one for the same levels, whereas <code>unstack()</code> pulls apart an index series for many periods into a collection of one-period indexes.</p>
<p>The first step to making a Paasche index is to unstack the elemental indexes into a list of elemental indexes for each period. (Trying to make the elemental indexes period-by-period can be dangerous when there are missing values.)</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" title="1">(ms_epr &lt;-<span class="st"> </span><span class="kw">unstack</span>(ms_epr))</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">#&gt; [[1]]</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">#&gt;    202001</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">#&gt; B1      1</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">#&gt; B2      1</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">#&gt; B3      1</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co">#&gt; B4    NaN</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="co">#&gt; [[2]]</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="co">#&gt;       202002</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">#&gt; B1 0.8949097</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">#&gt; B2       NaN</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="co">#&gt; B3 2.0200036</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co">#&gt; B4       NaN</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="co">#&gt; [[3]]</span></a>
<a class="sourceLine" id="cb36-17" title="17"><span class="co">#&gt;       202003</span></a>
<a class="sourceLine" id="cb36-18" title="18"><span class="co">#&gt; B1 0.3342939</span></a>
<a class="sourceLine" id="cb36-19" title="19"><span class="co">#&gt; B2       NaN</span></a>
<a class="sourceLine" id="cb36-20" title="20"><span class="co">#&gt; B3 1.6353355</span></a>
<a class="sourceLine" id="cb36-21" title="21"><span class="co">#&gt; B4       NaN</span></a>
<a class="sourceLine" id="cb36-22" title="22"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb36-23" title="23"><span class="co">#&gt; [[4]]</span></a>
<a class="sourceLine" id="cb36-24" title="24"><span class="co">#&gt;      202004</span></a>
<a class="sourceLine" id="cb36-25" title="25"><span class="co">#&gt; B1      NaN</span></a>
<a class="sourceLine" id="cb36-26" title="26"><span class="co">#&gt; B2 2.770456</span></a>
<a class="sourceLine" id="cb36-27" title="27"><span class="co">#&gt; B3 0.537996</span></a>
<a class="sourceLine" id="cb36-28" title="28"><span class="co">#&gt; B4 4.576286</span></a></code></pre></div>
<p>The second step is to make a sequence of aggregation structures for each set of weights.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" title="1">pias &lt;-<span class="st"> </span><span class="kw">with</span>(weights, </a>
<a class="sourceLine" id="cb37-2" title="2">             <span class="kw">Map</span>(aggregation_structure, </a>
<a class="sourceLine" id="cb37-3" title="3">                 <span class="kw">list</span>(hierarchy), </a>
<a class="sourceLine" id="cb37-4" title="4">                 <span class="kw">split</span>(weight, period))</a>
<a class="sourceLine" id="cb37-5" title="5">)</a></code></pre></div>
<p>Making the Paasche index for each period is now just a case of mapping the <code>aggregate()</code> function to each elemental index and aggregation structure, and then reducing the result with the <code>stack()</code> function.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" title="1">(paasche &lt;-<span class="st"> </span><span class="kw">Reduce</span>(stack, <span class="kw">Map</span>(aggregate, ms_epr, pias, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">r =</span> <span class="dv">-1</span>)))</a>
<a class="sourceLine" id="cb38-2" title="2"><span class="co">#&gt;    202001    202002    202003    202004</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="co">#&gt; 1       1 1.3127080 0.5874490 1.3591916</span></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="co">#&gt; 11      1 1.3127080 0.5874490 0.8839797</span></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="co">#&gt; 12      1 1.3127080 0.5874490 4.5762862</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="co">#&gt; B1      1 0.8949097 0.3342939 0.8839797</span></a>
<a class="sourceLine" id="cb38-7" title="7"><span class="co">#&gt; B2      1 1.3127080 0.5874490 2.7704563</span></a>
<a class="sourceLine" id="cb38-8" title="8"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.5379960</span></a>
<a class="sourceLine" id="cb38-9" title="9"><span class="co">#&gt; B4      1 1.3127080 0.5874490 4.5762862</span></a>
<a class="sourceLine" id="cb38-10" title="10"><span class="co">#&gt; B5      1 1.3127080 0.5874490 4.5762862</span></a></code></pre></div>
<p>With a Paasche index in hand, it is now trivial to make a Fisher index by first making the chained Laspeyres index, and then doing a simple matrix operation.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" title="1">laspeyres &lt;-<span class="st"> </span><span class="kw">Reduce</span>(stack, <span class="kw">Map</span>(aggregate, ms_epr, pias[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb39-2" title="2"><span class="kw">sqrt</span>(<span class="kw">as.matrix</span>(laspeyres) <span class="op">*</span><span class="st"> </span><span class="kw">as.matrix</span>(paasche))</a>
<a class="sourceLine" id="cb39-3" title="3"><span class="co">#&gt;    202001    202002    202003   202004</span></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="co">#&gt; 1       1 1.5107763 0.7956890 1.996688</span></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="co">#&gt; 11      1 1.5107763 0.7956890 1.192826</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="co">#&gt; 12      1 1.5107763 0.7956890 4.576286</span></a>
<a class="sourceLine" id="cb39-7" title="7"><span class="co">#&gt; B1      1 0.8949097 0.3342939 1.192826</span></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="co">#&gt; B2      1 1.5107763 0.7956890 2.770456</span></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="co">#&gt; B3      1 2.0200036 1.6353355 0.537996</span></a>
<a class="sourceLine" id="cb39-10" title="10"><span class="co">#&gt; B4      1 1.5107763 0.7956890 4.576286</span></a>
<a class="sourceLine" id="cb39-11" title="11"><span class="co">#&gt; B5      1 1.5107763 0.7956890 4.576286</span></a></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
